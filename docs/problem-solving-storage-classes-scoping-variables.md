# 存储类和变量范围的问题解决

> 原文:[https://www . geesforgeks . org/问题解决-存储-类-作用域-变量/](https://www.geeksforgeeks.org/problem-solving-storage-classes-scoping-variables/)

变量的存储类包括范围、可见性和生存期，它们有助于在程序运行时跟踪特定变量的存在。C 中存在四种类型的[存储类:自动、寄存器、静态和外部。](https://www.geeksforgeeks.org/storage-classes-in-c/)

**自动和注册存储类–**

*   使用自动或寄存器存储类声明的变量的范围是声明变量的函数或块。
*   变量的可见性是声明变量的函数或块。
*   变量的生命周期是从函数/块开始执行到函数/块终止的时间。
*   自动变量中变量的内存在堆栈上分配。
*   Auto 变量可以声明为 auto int i 或 int i。这意味着在函数中声明的变量的默认存储类是 auto。
*   [寄存器变量](https://www.geeksforgeeks.org/understanding-register-keyword/)可以声明为寄存器 int i，但是如果寄存器不可用，编译器会给它一个自动存储类。
*   如果 auto 或 register 变量未初始化，则它包含垃圾值。

**静态存储类别–**

*   使用静态存储类声明的变量的范围是在其中声明变量的函数或块。
*   变量的可见性是声明变量的函数或块。
*   静态变量保留在内存中，直到程序终止。因此，静态变量只初始化一次，静态变量的值在函数调用期间保持不变。
*   自动变量的内存在堆中分配，静态变量的内存在数据段中分配。详见[C 程序内存布局](https://www.geeksforgeeks.org/memory-layout-of-c-program/)。
*   静态变量可以声明为静态 int i。
*   如果静态变量在声明时没有初始化，它将被默认值初始化。整数为 0。

**外部存储类–**

*   Extern 存储类用于扩展变量的可见性，其中变量是在程序中的其他地方(同一文件或不同文件中)定义的。
*   Extern 变量可以声明为 extern int i。但是，内存并没有分配给 I，因为它引用了在程序中其他地方定义的另一个变量 I。

**局部/全局作用域–**
在函数或块内部声明的变量只有在该函数/块中才有作用域。但是，在函数外部声明的变量具有全局作用域，任何函数或块都可以访问该作用域。
T4【注:

*   如果函数具有与全局变量同名的局部/静态变量，则使用局部/静态值。
*   如果函数在局部范围内没有找到所需的变量，它将在全局范围内搜索该变量。如果它甚至在全局范围内都找不到，它将抛出一个错误。

**Que–1。**以下关于存储类的说法，哪一项是不正确的？
(一)具有自动存储类的变量在其声明的函数中具有局部作用域。
(B)静态存储类的变量在声明它的函数中有局部作用域。
(三)如果中央处理器中的寄存器不可用，带有寄存器存储类的变量声明将返回错误。
(D)无

**解决方案:**选项 A 和 B 是正确的，因为自动以及静态存储类具有本地范围。但是，选项 C 不正确，因为如果寄存器不可用，寄存器存储类将转换为自动存储类，并且它将给出警告而不是错误。

**Que–2。**以下 C 程序执行结束时 j 的值。(盖茨 CS 2000)

```cpp
int incr (int i)
{
   static int count = 0;
   count = count + i;
   return (count);
}
main ()
{
   int i, j;
   for (i = 0; i <=4; i++)
      j = incr(i);
}

```

(一)10
(二)4
(三)6
(四)7

**解决方案:**For 循环的执行方式为:
对于 i = 0，计数将在堆中分配内存并初始化为 0。语句 count = count +我将使 count = 0 + 0 = 0。
对于 i = 1，使用先前的计数值。语句 count = count +我将使 count = 0 + 1 = 1。
对于 i = 2，使用计数的先前值。语句 count = count +我将使 count = 1 + 2 = 3。
同样，对于 i = 3 和 4，分别将 3 和 4 添加到计数变量中。所以，答案会是 3 + 3 + 4 = 10。

**Que–3。**考虑以下 C 程序

```cpp
int a, b, c = 0;
void prtFun (void);
int main ()
{
    static int a = 1; /* line 1 */
    prtFun();
    a += 1;
    prtFun();
    printf ( "\n %d %d ", a, b) ;
}

void prtFun (void)
{
    static int a = 2; /* line 2 */
    int b = 1;
    a += ++ b;
    printf (" \n %d %d ", a, b);
}

```

给定的代码段将生成什么输出？
(一)

```cpp
3 1
4 1
4 2
```

(二)

```cpp
4 2
6 1
6 1
```

(三)

```cpp
4 2
6 2
2 0
```

(四)

```cpp
3 1
5 2
5 2
```

**解:**程序执行如下:
首先将全局变量 a、b、c 初始化为 0。调用 main 后，main 中的静态变量 a 将被初始化为 1。
首次调用 prtFun()时，静态变量 a 初始化为 2，局部变量 b 初始化为 1。语句 a+= +++ b 可以分解成++ b，然后是 a = a+b。因此，b 将增加到 2。另外，值 be a 将是 2+2 = 4。因此，print 语句将打印 4，2。从函数返回后，变量 b 将被销毁(局部范围)，a 的值将被保留。

从第一个 ptrFun()返回后，将执行语句 a+=1，main 中的静态变量 a 将增加到 2。
第二次调用 prtFun()时，局部变量 b 初始化为 1。语句 a+= +++ b 可以分解成++ b，然后是 a = a+b。因此，b 将增加到 2。此外，值 be a 将为= 4+2 = 6。因此，print 语句将打印 6，2。
从第二个 prtFun()返回后，主函数有值为 2 的静态变量 a 和值为 0 的全局变量 b。因此，会打印 2，0。
于是，答案是(丙)。

**Que–4。**考虑下面给出的 C 函数。

```cpp
int f(int j)
{
  static int i = 50;
  int k;
  if (i == j)
  {
    printf("something");
    k = f(i);
    return 0;
  }
  else return 0;
}

```

以下哪一项是正确的？
(A)对于 j.
的所有值，该函数返回 0(B)对于 j.
的所有值，该函数打印字符串某物(C)当 j = 50 时，该函数返回 0。
(D)当 j = 50 时，该函数将耗尽运行时堆栈或进入无限循环

**解决方法:**当 j 为 50 以外的任意值时，if 条件将失败，返回 0。
当 j 为 50 时，if 条件为真，函数被反复调用。它可能耗尽运行时堆栈或进入无限循环。
选项(D)正确。

**Que–5。**考虑如下所示的 C 程序。

```cpp
# include <stdio.h> 
# define print(x)  printf ("%d", x) 
int x; 
void Q(int z) 
{ 
  z += x;
  print(z); 
} 
void P(int *y) 
{ 
  int x = *y+2; 
  Q(x); 
  *y = x-1; 
  print(x);
} 

main(void) 
{ 
  x = 5; 
  P(&x); 
  print(x); 
  getchar();
} 

```

本程序输出为:(GATE CS 2003)
(A)12 7 6
(B)22 12 11
(C)14 6
(D)7 6 6

**解决方案:**变量 x 在 main()之外声明，main()具有全局作用域。此外，它也在 P()中声明。因此，P()将使用 x 局部到 P()。
First main()将全局 x 更改为 5。
函数 P()是通过传递全局 x 在 y 中的地址来调用的，因此 y 包含全局 x 的地址，
在 P 中声明了一个新的变量 x，并初始化为*y+2 = 5+2 = 7。因此，P()的局部 x 的值为 7。
函数 Q()是通过在 z 中传递 P()的局部 x 来调用的，因此 z 包含值 7。
语句 z +=x 会将全局 x 的值加到 z 上，因此会打印 z =z + x = 7+5 =12。
从 Q()返回后，将执行语句*y = x-1。由于局部 x 的值为 7，而 y 指的是全局 x，因此全局 x 的值将为 7-1 = 6。但是，print(x)将打印本地 x。因此，将打印 7。
从 P()返回后，主函数会打印 x(x 的全局值)，为 6。因此，将打印 6。
所以，输出是(A)。