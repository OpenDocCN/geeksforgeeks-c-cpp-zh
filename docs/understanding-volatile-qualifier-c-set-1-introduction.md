# 理解 C | Set 1(简介)

中的“volatile”限定词

> 原文:[https://www . geesforgeks . org/understand-volatile-qualifier-c-set-1-introduction/](https://www.geeksforgeeks.org/understanding-volatile-qualifier-c-set-1-introduction/)

尽管有大量关于 C 语言的文献，但是“ **volatile** ”关键字不知何故没有被很好地理解(即使是有经验的 C 程序员)。我们认为这主要是因为在用高级语言编写的典型 C 程序中没有一个真实世界的‘*volatile*’变量的用例。基本上，除非你用 C 语言做一些低级的硬件编程，否则当变量被限定为“ **volatile** ”时，你可能不会使用它。我们所说的低级编程是指一段处理外围设备、输入输出端口(主要是内存映射输入输出端口)、与硬件交互的中断服务例程的 C 代码。这就是为什么有一个可以轻松显示“ *volatile* ”关键字的确切效果的示例工作 C 程序不是那么简单的原因。
事实上，在本文中，如果我们能够解释一下“ *volatile* ”的含义和用途，那将为进一步研究和使用 C 语言中的“volatile”奠定基础。要理解“volatile”，我们首先需要有一些关于编译器对 C 程序做什么的背景知识。在高层次上，我们知道编译器将 C 代码转换成机器代码，这样可执行文件就可以在没有实际源代码的情况下运行。与其他技术类似，编译器技术也有了很大的发展。在将源代码翻译成机器代码时，编译器通常会尝试优化输出，以便最终需要执行的机器代码更少。其中一个优化是删除不必要的机器代码来访问变量，从编译器的角度来看，这是不会改变的。假设我们有以下代码:

## 卡片打印处理机（Card Print Processor 的缩写）

```cpp
uint32 status = 0;

while (status == 0)
{
  /*Let us assume that status isn't being changed
  in this while loop or may be in our whole program*/

  /*So long as status (which could be reflecting
  status of some IO port) is ZERO, do something*/
}
```

一个优化的编译器会看到在循环时*状态*没有被*改变。所以每次循环迭代后，不需要一次又一次地访问*状态*变量。所以编译器会将这个循环转换成无限循环，即*而(1)* ，这样就不需要读取*状态*的机器代码了。请注意，编译器不知道*状态*是一个特殊的变量，可以在任何时间点从当前程序之外进行更改，例如，某个输入输出操作发生在外围设备上，该设备的输入输出端口被内存映射到该变量。所以实际上，我们希望编译器在每次循环迭代后访问*状态*变量，即使它没有被编译器正在编译的程序修改。
有人可以说，我们可以关闭这类程序的所有编译器优化，这样就不会遇到这种情况。这不是一个选项，因为多种原因，例如
A)每个编译器实现都不同，所以它不是一个可移植的解决方案
B)仅仅因为一个变量，我们不想求助于编译器在我们程序的其他部分所做的所有其他优化。
C)通过关闭所有的优化，我们的低级程序不能像预期的那样工作，例如大小增加太多或执行延迟。
这就是图中出现“**挥发**”的地方。基本上，我们需要指示编译器*状态*是特殊变量，因此不允许对该变量进行这样的优化。有了这个，我们可以定义我们的变量如下:* 

## 卡片打印处理机（Card Print Processor 的缩写）

```cpp
volatile uint32 status = 0;
```

为了便于解释，我们选择了上面的例子。但总的来说， **volatile** 用于指针，例如:

## 卡片打印处理机（Card Print Processor 的缩写）

```cpp
volatile uint32 * statusPtr = 0xF1230000
```

这里，*statustr*指的是某个存储位置(例如，某个输入输出端口)，在该位置，内容可以在任何时间点从某个外围设备发生变化。请注意，我们的程序可能无法控制或了解内存何时会发生变化。因此，我们将它设为“**易失性的**，这样编译器就不会对*易失性的*变量进行优化，该变量由 *statusPtr* 指向。
在我们讨论“ **volatile** ”的上下文中，我们引用了 C 语言标准，即 ISO/IEC 9899 C11–第 6.7.3 条
*“具有 volatile 限定类型的对象可能以实现未知的方式被修改，或者具有其他未知的副作用。”*
*“易失性声明可用于描述对应于存储器映射输入/输出端口的对象或由异步中断功能访问的对象。除非表达式求值规则允许，否则对如此声明的对象的操作不应由实现“优化”或重新排序。*
基本上，C 标准说“ **volatile** ”变量可以从程序外部改变，这就是为什么编译器不应该优化它们的访问。现在，你可以猜测在你的程序中有太多的不稳定的 T21 变量也会导致更少的编译器优化。我们希望它能给你足够的背景知识，让你了解“不稳定”的含义和目的。
从这篇文章中，我们希望大家带走“ **volatile 变量–>不要为那个变量**做编译器优化”！
下面的文章通过更多的例子来解释 volatile。
[理解 C | Set 2 中的“volatile”限定词(举例)](https://www.geeksforgeeks.org/understanding-volatile-qualifier-in-c/)
如果你喜欢 GeeksforGeeks 并愿意投稿，也可以使用[write.geeksforgeeks.org](http://www.write.geeksforgeeks.org)写一篇文章或者把文章邮寄到 review-team@geeksforgeeks.org。看到你的文章出现在极客博客主页上，帮助其他极客。
如果发现有不正确的地方，或者想分享更多关于上述话题的信息，请写评论。