# c++ 代码膨胀示例

> 原文:[https://www . geesforgeks . org/code-膨胀-in-c-with-examples/](https://www.geeksforgeeks.org/code-bloating-in-c-with-examples/)

**代码膨胀**是被认为是不必要的长、慢或浪费资源的代码的产生。这是软件开发中的一个问题，它使得软件代码的长度不必要地变长。所以为了编写高质量的代码，我们总是避免程序中的代码膨胀。

以下是代码膨胀的一些**原因:**

*   **Headers:** Suppose we have declare some functions in Header File as shown below:

    ```cpp
    #include <vector>

    // Function to find the sum of elements
    // in a vector
    inline int findSum(vector<int>& arr, int N)
    {
        int sum = 0;
        for (int i = 0; i < N; i++) {
            sum += arr[i];
        }
        return sum;
    }

    struct GfG {

        // Declare vector arr
        std::vector<int> arr;

        // Function
        int execute() const
        {
            return findSum(arr, arr.size());
        }
    };
    ```

    在上面的头文件中，当我们在任何源代码中单独使用上面的头文件时，每次都会编译函数 **execute()** 和 **findSum()** 。如果我们包含任何头文件，并且不使用该头文件中的任何功能，那么每次它仍然会编译头文件的功能和所有其他特性，这会减慢每个软件的构建时间。当项目很大时，它包含数百个源文件，头中定义的每个函数都被编译了数百次。这种为软件开发编写代码的做法会导致代码膨胀，即不必要的功能声明。

*   **Templates:**
    In C++ we have built-in [templates](https://www.geeksforgeeks.org/templates-cpp/) for functions and [containers](https://www.geeksforgeeks.org/containers-cpp-stl/). Templates are the generalized form of functionality with different data types. Every instance of a template is a completely separate piece of code generated by the compiler.
    Consider below an example for templates:

    ```cpp
    template <class T>
    T findSum(const T* arr, int num)
    {
        return accumulate(arr, arr + num, T(0));
    }

    template <class T, int N>
    struct GfG {
        T arr[N];
        T run() const
        {
            T res = 0;
            for (int i = 0; i < N; i++)
                res += arr[i];
            return res;
        }
    };
    ```

    在上面的模板函数中 **findSum()** 每使用一种模板参数 **T** 编译一次。
    对不同的**对调用 **run()** 方法时，会多次编译 **GfG::run()** 中的函数。该功能可以花更多时间更改 **N** 的值。有各种技术来克服这个问题。头文件的问题也适用于模板，因为模板几乎总是在头文件中定义的。**

     **有两种方法可以克服这个问题:

    1.  在源文件中定义模板函数并显式实例化它们。
    2.  在头文件中使用 extern 模板声明，结合源文件本身中的显式模板实例。** 

****程序:****

```cpp
#include <iostream>
using namespace std;

// Driver Code
int main()
{
    // Code Bloating
    string str("GeeksForGeeks");

    // Print string str
    cout << str << endl;
    return 0;
}
```

****Output:**

```cpp
GeeksForGeeks

```** 

**上述程序将完美运行，并将打印 **GeeksForGeeks** 。但是在主函数的第一行上面的程序中有一个代码膨胀的问题。以上程序的议程是打印字符串 **GeeksForGeeks** ，那么为什么我们要创建字符串类的对象，因为它导致创建字符串类对象。
我们可以简单地写**

```cpp
**cout << "GeeksForGeeks" << endl;** 
```

****代码膨胀的效果:****

*   **它不必要地创建了一些类的对象，这会使我们的软件执行缓慢。**
*   **这是软件开发中的一个问题，使得软件的代码长度不必要地变长。**