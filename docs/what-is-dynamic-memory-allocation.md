# 什么是动态内存分配？

> 原文:[https://www . geesforgeks . org/什么是动态内存分配/](https://www.geeksforgeeks.org/what-is-dynamic-memory-allocation/)

资源永远是一种溢价。我们一直努力实现资源的更好利用；这是我们进步的前提。与这种追求相关的，是内存分配的概念。
内存必须分配给我们创建的变量，这样实际的变量才能存在。现在有一个约束，我们认为它是如何发生的，以及它实际上是如何发生的。
**计算机如何创建变量？**
当我们想到创造一些东西时，我们会想到从头开始创造一些东西，而这并不是计算机创造变量‘X’时实际发生的情况；对计算机来说，更像是一种分配，计算机只是将大量已有存储单元中的一个存储单元分配给 x，就像一个叫‘RAJESH’的人被从大量空闲或空的已有房间中分配到一个酒店房间。这个例子可能非常清楚地说明了计算机是如何分配内存的。
现在，什么是**静态内存分配**？当我们声明变量时，我们实际上是在准备将要使用的所有变量，这样编译器就知道正在使用的变量实际上是用户想要的程序的重要部分，而不仅仅是一个四处浮动的流氓符号。因此，当我们声明变量时，编译器实际上做的是将这些变量分配给它们的房间(参考前面的酒店类比)。现在，如果你看到，这是在程序执行之前完成的，你不能在程序执行时用这个方法分配变量。

## 卡片打印处理机（Card Print Processor 的缩写）

```cpp
// All the variables in below program
// are statically allocated.
void fun()
{
   int a;
}
int main()
{
   int b;
   int c[10]
}
```

**如果这只是完成工作，为什么我们需要引入另一种分配方法？**为什么我们需要在程序执行时分配内存？因为，即使它不是明显可见的，在运行时不能分配内存也排除了灵活性和空间效率的折衷。特别是，在事先不知道输入的情况下，我们会遇到低效的存储使用以及缺少或过多的插槽来输入数据(给定一个数组或类似的数据结构来存储条目)。所以，这里我们定义了动态内存分配:**在运行期间可以将存储/内存/单元分配给变量的机制称为动态内存分配(不要与** [**DMA**](https://practice.geeksforgeeks.org/problems/direct-memory-access-dma) **混淆)。**因此，当我们已经经历了这一切时，我们可以看出它在运行时分配了内存，这使我们能够使用任意多的存储空间，而不用担心任何浪费。

> 动态内存分配是在执行时或运行时分配内存空间的过程。

**动态分配内存的原因及优势:**

1.  当我们事先不知道程序需要多少内存时。
2.  当我们想要没有任何内存空间上限的数据结构时。
3.  当你想更有效地利用你的记忆空间。*示例:*如果您已经将 1D 数组的内存空间分配为数组[20]，并且最终只使用了 10 个内存空间，那么剩余的 10 个内存空间将被浪费，并且这种浪费的内存甚至不能被其他程序变量利用。
4.  动态创建的列表插入和删除可以很容易地完成，只需操作地址，而在静态分配内存的情况下，插入和删除会导致更多的移动和内存浪费。
5.  当你想在编程中使用结构和链表的概念时，动态内存分配是必须的。

## 卡片打印处理机（Card Print Processor 的缩写）

```cpp
int main()
{
   // Below variables are allocated memory
   // dynamically.
   int *ptr1 = new int;
   int *ptr2 = new int[10];

   // Dynamically allocated memory is
   // deallocated
   delete ptr1;
   delete [] ptr2;
}
```

**有两种类型的可用内存——堆栈和堆。**静态内存分配只能在堆栈上完成，而动态内存分配可以在堆栈和堆上完成。要在堆栈上进行的动态分配的一个例子是递归，其中函数按其出现的顺序放入调用堆栈，并在到达基本情况时逐个弹出。堆上动态内存分配的例子是:

## 卡片打印处理机（Card Print Processor 的缩写）

```cpp
int main()
{
   // Below variables are allocated memory
   // dynamically on heap.
   int *ptr1 = new int;
   int *ptr2 = new int[10];

   // Dynamically allocated memory is
   // deallocated
   delete ptr1;
   delete [] ptr2;
}
```

**在堆上分配内存时，我们需要手动删除内存，因为即使分配的内存范围结束(如堆栈的情况)，内存也不会被编译器释放(解除分配)。**
总结以上话题，静态内存是编译器提前分配的东西。而动态内存是在执行过程中由程序控制的东西。程序可能会要求更多，或者可能会删除一些已分配的。