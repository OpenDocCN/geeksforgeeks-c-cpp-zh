# 空指针在 C

> 原文:[https://www . geeksforgeeks . org/c 中空指针上的几个字节/](https://www.geeksforgeeks.org/few-bytes-on-null-pointer-in-c/)

在很高的层次上，我们可以把空看作一个空指针，它在 C 语言中被用于各种目的。空值的一些最常见的用例是
a)当指针变量还没有被分配任何有效的内存地址时，初始化该指针变量。
b)在访问任何指针变量之前检查空指针。通过这样做，我们可以在指针相关的代码中执行错误处理，例如，只有当指针变量不为空时才取消引用指针变量。
c)当我们不想传递任何有效的内存地址时，传递一个指向函数参数的空指针。

的示例是

```cpp
int * pInt = NULL;
```

b 的例子是

```cpp
if(pInt != NULL) /*We could use if(pInt) as well*/
{ /*Some code*/}
else
{ /*Some code*/}
```

c 的例子是

```cpp
int fun(int *ptr)
{
 /*Fun specific stuff is done with ptr here*/
 return 10;
}
fun(NULL);
```

需要注意的是，空指针不同于未初始化的悬空指针。在特定的程序上下文中，所有未初始化的或悬空的或空指针都是无效的，但空指针是一种特定的无效指针，在 C 标准中有所提及，并有特定的用途。我们的意思是，未初始化的和悬空的指针是无效的，但是它们可以指向一些可以通过内存访问访问的内存地址，这是无意的。

```cpp
#include <stdio.h>
int main()
{
 int *i, *j;
 int *ii = NULL, *jj = NULL;
 if(i == j)
 {
  printf("This might get printed if both i and j are same by chance.");
 }
 if(ii == jj)
 {
  printf("This is always printed coz ii and jj are same.");
 }
 return 0;
}
```

通过特别提到空指针，C 标准给出了一种机制，C 程序员可以使用这种机制来检查给定的指针是否合法。但是空值到底是什么，它是如何定义的？严格来说，null 扩展为实现定义的 NULL 指针常量，在很多头文件中都有定义，比如“ *stdio.h* ”、“ *stddef.h* ”、“ *stdlib.h* 等。让我们看看 C 标准是怎么说空指针的。根据 6.3.2.3 C11 标准条款，

"*值为 0 的整数常量表达式，或者转换为 void *类型的表达式，称为空指针常量。如果将空指针常量转换为指针类型，则生成的指针(称为空指针)保证与指向任何对象或函数的指针不相等。*”

在我们进一步讨论这个空值之前:)，让我们提几行关于 C 标准的内容，以防你想引用它做进一步的研究。请注意，国际标准化组织/IEC 9899:2011 是 C 语言的最新标准，于 2011 年 12 月发布。这也叫 C11 标准。为了完整起见，让我们提到以前的 C 标准是 C99、C90(也称为 ISO C)和 C89(也称为 ANSI C)。虽然实际的 C11 标准可以从国际标准化组织购买，但有一份草案文件可以在公共领域免费获得。

进入我们的讨论，在大多数 C 编译器实现的头文件中，NULL 宏被定义为 *((void *)0)* 。但是 C 标准是说 0 也是空指针常量。这意味着根据标准，以下内容也是完全合法的。

```cpp
int * ptr = 0;
```

请注意，上面 C 语句中的 0 是在指针上下文中使用的，它不同于作为整数的 0。这就是为什么首选使用 null 的原因之一，因为它在代码中明确表示程序员使用的是 NULL 指针，而不是整数 0。关于 NULL 的另一个重要概念是“ *NULL 扩展为实现定义的 NULL 指针常量*”。这一说法也来自 C11 第 7.19 条。这意味着空指针的内部表示可以是非零位模式来传送空指针。这就是为什么空值不需要在内部表示为全零位模式。编译器实现可以选择将“空指针常数”表示为全 1 的位模式或任何其他模式。但同样，作为一名 C 程序员，我们不必太担心空指针的内部值，除非我们参与编译器编码，甚至低于编码水平。说了这么多，通常空值被表示为所有的位只被设置为 0。要在特定平台上了解这一点，可以使用以下方法

```cpp
#include<stdio.h>
int main()
{
 printf("%d",NULL);
 return 0;
}
```

最有可能的是，它打印的是 0，这是典型的内部空指针值，但它也可能因 C 编译器/平台而异。你可以在上面的程序中尝试一些其他的东西，比如*printf(“% c”，空)*或者*printf(“% s”，空)*甚至*printf(“% f”，空)*。根据使用的平台不同，这些输出会有所不同，但是使用带有空值的 *%f* 会很有趣！

我们可以在 C 语言的 NULL 上使用 *sizeof()* 运算符吗？嗯，允许使用*大小为(空)*，但具体大小取决于平台。

```cpp
#include<stdio.h>
int main()
{
 printf("%lu",sizeof(NULL));
 return 0;
}
```

由于空被定义为 *((void*)0)* ，我们可以把空看作一个特殊的指针，它的大小等于任何指针。如果一个平台的指针大小是 4 字节，那么上述程序的输出将是 4。但是如果一个平台上的指针大小是 8 字节，那么上述程序的输出将是 8。

空值的解引用怎么办？如果我们使用下面的 C 代码会发生什么

```cpp
#include<stdio.h>
int main()
{
 int * ptr = NULL;
 printf("%d",*ptr);
 return 0;
}
```

在某些机器上，上述程序可以成功编译，但是当程序运行时会崩溃，它不需要在所有机器上显示相同的行为。同样，这取决于很多因素。但是提到上面的代码片段的想法是，我们应该在访问它之前总是检查空值。

由于空通常被定义为 *((void*)0)* ，让我们也讨论一下 *void* 类型。根据 C11 标准第 6.2.5 条，“*无效类型包括一组空值；是不能完成的不完整对象类型*。甚至 C11 条款 6.5.3.4 也提到“*sizeof 运算符不应应用于具有函数类型或不完整类型的表达式、此类类型的带圆括号名称或指定位字段成员的表达式。*“基本上就是说 *void* 是一个不完整的类型，它的大小在 C 程序中没有任何意义，但是实现(比如 gcc)可以选择 *sizeof(void)* 为 1，这样 void 指针指向的平面内存就可以看作是非类型内存，也就是一个字节序列。但是下面的输出不必在所有平台上都相同。

```cpp
#include<stdio.h>
int main()
{
 printf("%lu",sizeof(void));
 return 0;
}
```

在 gcc 上，上面将输出 1。*大小的(void *)* 呢？这里 C11 已经提到了指南。从第 6.2.5 条开始，“*指向 void 的指针应具有与指向字符类型*的指针相同的表示和对齐要求”。这就是为什么下面的输出会和机器上的任何指针大小一样。

```cpp
#include<stdio.h>
int main()
{
 printf("%lu",sizeof(void *));
 return 0;
}
```

除了上面提到的机器相关的东西，我们作为 C 程序员应该始终努力使我们的代码尽可能的可移植。因此，我们可以对空值得出如下结论:

1.始终将指针变量初始化为空。
2。在访问任何指针之前，请始终执行空检查。

如果你觉得以上有用，请做 Like/Tweet/G+1。此外，请让我们评论进一步澄清或信息。我们很乐意帮助和学习🙂